Report

Abstraction: The graph created is the dynamic graph. By dynamic, it means instead of creating the graph for every city present in the data-set, we created a graph just by only considering the start city and the corresponding cities interconnected to it (both uni-directional and bi-directional). This implementation reduced the size of the graph “exponentially”. Also, another touch of fast access to the nodes was given by creating a graph using dictionary (every parent node being the key for its child node being the value of that node).
(1)	Which search algorithm seems to work best for each routing options?

Answer: Elimination of DFS was an easy choice for the finding minimum cost path. BFS is useful in finding shortest path while DFS is much better in finding the path between vertexes. Uniform cost function uses the relative cost between the edges and A* uses the heuristic function which adds to uniform cost to provide the more optimal path. But when it comes to uniform cost, it is surely to find the path as it does not depend on the heuristic (which can be buggy at times and that depends on the admissibility and further on being consistent) and instead depends on the minimum cost of every node. So accordingly, under the circumstance of heuristic not being optimistically admissible, I would consider uniform cost search as the best algorithm that would work for each routing options.


(2)	Which algorithm is fastest in terms of the amount of computation time required by your program, and by how much, according to your experiments? 

Answer: According to my program, uniform search cost performs much better in terms of time complexity as there is no overhead of performance in terms of creating the heuristic because it takes only the edge weight into consideration. As the function call for heuristic, it takes in the argument as start city and end city; it loops through the city_gps.txt every time it needs to find the heuristic between the current city and the end city. This creates and overhead of looping through the file which takes more time to finish the overall performance of the algorithm. When USC is compared with BFS, USC has a definitive area to explore every time it goes towards the goal state. That said, as the depth increases, the path become narrower toward the goal whereas, with BFS, it has to explore every node by travelling through its breadth. Also, if compared between BFS and DFS, DFS takes much more time than BFS to complete finding of shortest path. 

(3)	Which algorithm requires the least memory, and by how much, according to your experiments? 
Answer: Even though BFS finds the shortest path more likely then DFS but DFS is space effective than BFS because if the goal is at the last leaf of the graph, it would cost more in BFS then DFS. While considering A* and uniform search, the extra dictionaries were used to keep track of the visited node and the corresponding cost from which it came. Therefore, according to our program, DFS was space effective then all the three algorithms.

(4)	Which heuristic function(s) did you use, how good is it, and how might you make it/them better?
Answer: We have used “Haversine formula” to calculate the heuristic function as the latitude and longitudes were provided. Haversine formula was chosen over Euclidian’s formula because Euclidian distance would have been the choice but the elimination of Euclidian distance was for the fact that the earth is spherical and the heuristic that would have been gathered from it would not have been significant as it is with Haversine formula. It came close to the actual distance, so it was the choice of heuristic which also consider the angles of the earth.
For our data sets, highways are not present in the city_gps.txt file. So a change has been made that if a city comes such that it was not present in the file, it would return 0 making it not return an absurd value for the segments which actually does not exists.  