#!/usr/bin/env python

# put your group assignment problem here!
##initial state: [[],[]] , a list of teams such that, Every student is in a team of 1 person, each team is a list itself

##state space: set of all possible groupings of the students

##successor function: for a given state generate all possible states that can be generated by combining any two teams
# therefore if there are T teams at the current state then we have C(T,2) successors

#evaluation function: cost function, gives the time required by the instructors if this state is the output

##Strategy used: Local search 

#1 steepest descent
#	at each step, find all successors of a given state
#	expand only the state that has the lowest cost

#2 monte carlo descent
#	at each state find all successors
# 	if the cost of a successor is less than the current state chose that state
#	else chose the successor with a probability of e^((cost(s) - cost(s'))/t)
#	expand the successor 
#	repeat till some local minima is reached ie, no successors have cost < current state
#	repeat the process K times
#	chose the best result of K iterations

#input format ./assign.py [input_file] [k] [m] [n]
import sys
import random
import math

def readFile(filename):
	"""

	"""
	student_dict ={}
	with open(filename, 'r') as f:
		l = f.readline()
		
		while l != "":
			student_id, team_size, want_list , avoid_list = l.strip().split(' ')
			student_dict[student_id] = {'team_size': int(team_size),
										'want': want_list.split(",") if want_list != "_" else [],
										'avoid': avoid_list.split(",") if avoid_list != "_" else []
										}
			l = f.readline()
	f.close() 
	return student_dict

def generateInitialState(responses):
	#returns a initial state
	initialState = []
	for k,v in responses.iteritems():
		initialState.append([k])

	return initialState

def printOutput(state, cost=0):
	#prints in correct format
	for team in state:
		string = ' '.join(team)
		print string
	print cost
	return

def findCost(state, responses):
	
	m = 0
	n = 0
	k = 0
	ts = 0
	want = 'want'
	avoid = 'avoid'
	for team in state:
		for student in team:
			for other in team:
				if other != student and other in responses[student][avoid]:
					m += 1
			for friend in responses[student][want]:
				if friend not in team:
					n += 1
			team_size = len(team)
			requested_team_size = responses[student]['team_size']
			if requested_team_size != team_size and requested_team_size != 0:
				ts += 1
		k +=1

	cost = K*k + M*m + N*n + ts
	return cost

def successors(state):
	successors = []
	teams = len(state)
	for i in range(teams):
		for j in range(i+1, teams):
			if len(state[i] + state[j]) <=3:
				new_state = state[:]
				new_state.append(state[i] + state[j])
				new_state.remove(state[i])
				new_state.remove(state[j])
				successors.append(new_state)
	#if len(successors) == 0:
	#	successors = [state]
	return successors

def steepestDescent(initialState, max_depth = 50, max_iters=10):

	#look for overall best solution in multiple tries
	#depth only works if randomly settig initial state otherwise whats the point
	current =  initialState
	best_cost = findCost(initialState, responses)
	
	while True:
	
		successorList  = successors(current)
		if len(successorList) == 0:
			break

		costs = [findCost(s, responses) for s in successorList]
		new_best_cost = min(costs)
		if new_best_cost >= best_cost:
			#solution_found = True
			break
		else:
			best_cost = new_best_cost
			current = successorList[costs.index(new_best_cost)]

	#returns goal state and cost
	return current, best_cost


#Effect of depth, iters, T on performance
#bad path selected%
#time difference between MC and SD

def monteCarloDescent(initialState, iterations=100, T = 1000, max_depth = 100):
	#returns goal state and cost

	
	best_sol = None
	best_cost = findCost(initialState, responses)
	for k in range(iterations):
		steps = 0
		bad_steps = 0
		current = initialState
		current_cost = findCost(initialState, responses)

		depth = 0
		while True:

			successorList = successors(current)
			
			if depth > max_depth or len(successorList) == 0:
				break

			random_successor = random.choice(successorList)
			successor_cost = findCost(random_successor, responses)

			print successor_cost , current_cost
			if successor_cost < current_cost:
				#print "here1"
				current = random_successor
				current_cost = successor_cost
			else:
				randnum = random.random()
				value = (current_cost - successor_cost)/T
				if randnum < math.exp(value):
					bad_steps +=1
					current = random_successor
					current_cost = successor_cost
						
		if current_cost< best_cost:
			best_cost = current_cost
			best_sol = current 
		
		T = T/10.0
	return best_sol , best_cost

if __name__ == '__main__':

	filename = str(sys.argv[1])
	K = int(sys.argv[2])
	M = int(sys.argv[3])
	N = int(sys.argv[4])

	responses = readFile(filename)
	
	initialState = generateInitialState(responses)
	#goal, cost = steepestDescent(initialState)
	#printOutput(goal,cost)

	goal,cost = monteCarloDescent(initialState)
	printOutput(goal,cost)
