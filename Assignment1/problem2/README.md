##Problem 2

Abstraction:

* initial state: [[],[]] , a list of teams such that, Every student is in a team of 1 person, each team is a list itself
* state space: set of all possible groupings of the students
* successor function: for a given state generate all possible states that can be generated by combining any two teams such that no team has more than 3 people in it
 therefore if there are T teams at the current state then we have C(T,2) successors 

*evaluation function: cost function, gives the time required by the instructors if this state is the output


###Strategy used :Local search
1. the number of states can be very huge to search using search strategies like BFS or DFS
2. There can be multiple goal states
	any state can be a goal state and we need to return the best state we can find in a reasonable time

# cost function hyperplane

#steepest descent
When using steepest descent, at each state, we see the successor states and chose only that state that seems to be the best at this moment
Thus at each step we chose the succesor that has the minimum cost among the successors
If no successors have a better cost than the current state, we can say that we have reached the local minima and break

since, we are not setting the initial state at random, and we know that we will reahch a local minima every time, and therefore we can return a goal state at each time, we do not need to repeat the process k times to get a reasonable output

#monte carlo descent
In case of steepest descent, we only take the best successor at every step. This may lead to never reaching a better goal state if the oath to it goes through some bad states.
Therefore, using randomness, we can argue that atleast some times we will get a result that is better than what we get from steepest descen
Thus we compare the result of various iterations and give the best result from all those iterations.

Also, since our steepest descent algorithm breaks only when it reaches a local minimum, it can fail to give outpu tn a reasonable time when the input file has a large number of students.
In monte carlo descent we can set a value of depth that we can explore on each iteration and the number of iterations needed to get a result in a reasonable amount of time.

Therefore, monte carlo descent can give a better result than steepest descent sometimes, and when it gives a poorer result, the cost difference is not too large, in a reasonable amount of time.
Therefore, Monte carlo descent has been chosen as the default algorithm for this problem.

#comparison of input with finlal cost and time
tables etc

#what bounds are selected for this case
what values of depth, iterations, T are selected to run for n=100 in 3 mins
what time it takes to run for 100, 150, 200 and what are the results.

